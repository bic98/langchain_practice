# OpenAI Apps SDK 완벽 학습 가이드 - 6부: 실전 가이드

## 📚 목차
1. [새로운 위젯 만들기](#1-새로운-위젯-만들기)
2. [데이터 소스 연동](#2-데이터-소스-연동)
3. [고급 기능 구현](#3-고급-기능-구현)
4. [성능 최적화](#4-성능-최적화)
5. [디버깅과 문제 해결](#5-디버깅과-문제-해결)
6. [배포 체크리스트](#6-배포-체크리스트)

---

## 1. 새로운 위젯 만들기

### 1.1 날씨 위젯 만들기 (완전 예제)

**목표:** 현재 날씨와 5일 예보를 보여주는 위젯

**1단계: 프로젝트 구조 생성**
```bash
# 위젯 디렉토리 생성
mkdir -p src/weather

# 파일 생성
touch src/weather/index.jsx
touch src/weather/WeatherCard.jsx
touch src/weather/weather.css
```

**2단계: WeatherCard 컴포넌트**
```jsx
// src/weather/WeatherCard.jsx
import { Cloud, CloudRain, Sun, Wind } from 'lucide-react';

function getWeatherIcon(condition) {
  const icons = {
    sunny: Sun,
    cloudy: Cloud,
    rainy: CloudRain,
    windy: Wind
  };
  const Icon = icons[condition] || Sun;
  return <Icon className="w-12 h-12" />;
}

export default function WeatherCard({ day, temp, condition }) {
  return (
    <div className="flex flex-col items-center p-4 rounded-lg bg-white shadow-sm">
      <p className="text-sm font-medium text-gray-600">{day}</p>
      <div className="my-3">
        {getWeatherIcon(condition)}
      </div>
      <p className="text-2xl font-bold">{temp}°C</p>
      <p className="text-xs text-gray-500 capitalize">{condition}</p>
    </div>
  );
}
```

**3단계: 메인 컴포넌트**
```jsx
// src/weather/index.jsx
import { createRoot } from 'react-dom/client';
import { useWidgetProps } from '../use-widget-props';
import { useDisplayMode } from '../use-display-mode';
import { useMaxHeight } from '../use-max-height';
import WeatherCard from './WeatherCard';
import './weather.css';

function WeatherWidget() {
  // MCP 서버에서 전달받은 데이터
  const { city, current, forecast } = useWidgetProps({
    city: "서울",
    current: { temp: 22, condition: "sunny" },
    forecast: [
      { day: "월", temp: 23, condition: "cloudy" },
      { day: "화", temp: 21, condition: "rainy" },
      { day: "수", temp: 24, condition: "sunny" },
      { day: "목", temp: 22, condition: "cloudy" },
      { day: "금", temp: 25, condition: "sunny" }
    ]
  });

  const displayMode = useDisplayMode();
  const maxHeight = useMaxHeight();

  return (
    <div
      className="p-6 bg-gradient-to-br from-blue-50 to-blue-100"
      style={{
        maxHeight,
        height: displayMode === "fullscreen" ? maxHeight : 480
      }}
    >
      {/* 헤더 */}
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-gray-800">{city}</h1>
        <p className="text-sm text-gray-600">현재 날씨</p>
      </div>

      {/* 현재 날씨 */}
      <div className="mb-8 p-6 rounded-2xl bg-white shadow-lg">
        <div className="flex items-center justify-between">
          <div>
            <p className="text-5xl font-bold text-gray-800">
              {current.temp}°C
            </p>
            <p className="text-lg text-gray-600 capitalize mt-2">
              {current.condition}
            </p>
          </div>
          <div className="text-blue-500">
            {getWeatherIcon(current.condition)}
          </div>
        </div>
      </div>

      {/* 5일 예보 */}
      <div>
        <h2 className="text-xl font-semibold text-gray-800 mb-4">
          5일 예보
        </h2>
        <div className="grid grid-cols-5 gap-3">
          {forecast.map((day, index) => (
            <WeatherCard key={index} {...day} />
          ))}
        </div>
      </div>
    </div>
  );
}

createRoot(document.getElementById('weather-root')).render(<WeatherWidget />);

export default WeatherWidget;
```

**4단계: CSS 스타일**
```css
/* src/weather/weather.css */
.weather-widget {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

@media (max-width: 768px) {
  .weather-widget {
    padding: 1rem;
  }
}
```

**5단계: MCP 서버에 도구 추가 (Node.js)**
```typescript
// pizzaz_server_node/src/server.ts
const widgets: PizzazWidget[] = [
  // ... 기존 위젯들
  {
    id: "weather-widget",
    title: "Show Weather Widget",
    templateUri: "ui://widget/weather-widget.html",
    invoking: "Checking the weather",
    invoked: "Weather loaded",
    html: readWidgetHtml("weather"),
    responseText: "Here's the weather information!"
  }
];

// 입력 스키마 확장
const weatherInputSchema = {
  type: "object",
  properties: {
    city: {
      type: "string",
      description: "City name to get weather for"
    }
  },
  required: ["city"]
};
```

**6단계: 빌드 및 테스트**
```bash
# 빌드
pnpm build

# MCP 서버 시작
cd pizzaz_server_node
pnpm start

# 브라우저에서 확인
# http://localhost:4444/weather.html
```

### 1.2 Chart 위젯 만들기

**Chart.js를 사용한 그래프 위젯**

**1단계: 의존성 추가**
```bash
pnpm add chart.js react-chartjs-2
```

**2단계: Chart 컴포넌트**
```jsx
// src/chart/index.jsx
import { createRoot } from 'react-dom/client';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend
} from 'chart.js';
import { Bar } from 'react-chartjs-2';
import { useWidgetProps } from '../use-widget-props';

// Chart.js 등록
ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  Title,
  Tooltip,
  Legend
);

function ChartWidget() {
  const { title, labels, datasets } = useWidgetProps({
    title: "월별 매출",
    labels: ['1월', '2월', '3월', '4월', '5월', '6월'],
    datasets: [
      {
        label: '매출 (만원)',
        data: [120, 190, 300, 500, 200, 300],
        backgroundColor: 'rgba(54, 162, 235, 0.5)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1
      }
    ]
  });

  const options = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'top'
      },
      title: {
        display: true,
        text: title
      }
    }
  };

  const data = {
    labels,
    datasets
  };

  return (
    <div className="p-6" style={{ height: 480 }}>
      <Bar options={options} data={data} />
    </div>
  );
}

createRoot(document.getElementById('chart-root')).render(<ChartWidget />);
```

---

## 2. 데이터 소스 연동

### 2.1 REST API 연동

**예제: 실시간 날씨 API 사용**

```jsx
// src/weather/index.jsx
import { useState, useEffect } from 'react';

function WeatherWidget() {
  const { city } = useWidgetProps({ city: "서울" });
  const [weather, setWeather] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchWeather() {
      try {
        setLoading(true);
        const response = await fetch(
          `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=YOUR_API_KEY&units=metric`
        );

        if (!response.ok) {
          throw new Error('Failed to fetch weather');
        }

        const data = await response.json();
        setWeather({
          temp: Math.round(data.main.temp),
          condition: data.weather[0].main.toLowerCase(),
          humidity: data.main.humidity,
          windSpeed: data.wind.speed
        });
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    fetchWeather();
  }, [city]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500" />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-red-500">
          오류: {error}
        </div>
      </div>
    );
  }

  return (
    <div>
      <h1>{city}</h1>
      <p>{weather.temp}°C</p>
      <p>{weather.condition}</p>
    </div>
  );
}
```

### 2.2 MCP 서버에서 API 호출

**Node.js 서버에서 데이터 가져오기:**

```typescript
// pizzaz_server_node/src/server.ts
import fetch from 'node-fetch';

server.setRequestHandler(
  CallToolRequestSchema,
  async (request: CallToolRequest) => {
    if (request.params.name === "weather-widget") {
      const args = request.params.arguments as { city: string };

      // API 호출
      const response = await fetch(
        `https://api.openweathermap.org/data/2.5/weather?q=${args.city}&appid=${API_KEY}&units=metric`
      );

      const data = await response.json();

      return {
        content: [
          {
            type: "text",
            text: `Weather for ${args.city}: ${data.main.temp}°C`
          }
        ],
        structuredContent: {
          city: args.city,
          current: {
            temp: Math.round(data.main.temp),
            condition: data.weather[0].main.toLowerCase(),
            humidity: data.main.humidity,
            windSpeed: data.wind.speed
          }
        },
        _meta: widgetMeta(widget)
      };
    }
  }
);
```

**Python 서버에서 데이터 가져오기:**

```python
# pizzaz_server_python/main.py
import httpx

async def _call_tool_request(req: types.CallToolRequest):
    if req.params.name == "weather-widget":
        args = req.params.arguments
        city = args.get("city", "Seoul")

        # API 호출
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"https://api.openweathermap.org/data/2.5/weather",
                params={
                    "q": city,
                    "appid": API_KEY,
                    "units": "metric"
                }
            )
            data = response.json()

        return types.ServerResult(
            types.CallToolResult(
                content=[
                    types.TextContent(
                        type="text",
                        text=f"Weather for {city}: {data['main']['temp']}°C"
                    )
                ],
                structuredContent={
                    "city": city,
                    "current": {
                        "temp": round(data["main"]["temp"]),
                        "condition": data["weather"][0]["main"].lower(),
                        "humidity": data["main"]["humidity"],
                        "windSpeed": data["wind"]["speed"]
                    }
                },
                _meta=_tool_meta(widget)
            )
        )
```

### 2.3 데이터베이스 연동

**PostgreSQL 연동 예제 (Node.js):**

```typescript
// pizzaz_server_node/src/db.ts
import { Pool } from 'pg';

const pool = new Pool({
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD
});

export async function getUserData(userId: string) {
  const result = await pool.query(
    'SELECT * FROM users WHERE id = $1',
    [userId]
  );
  return result.rows[0];
}

// 서버에서 사용
server.setRequestHandler(
  CallToolRequestSchema,
  async (request: CallToolRequest) => {
    const userData = await getUserData(request.params.arguments.userId);

    return {
      content: [...],
      structuredContent: userData,
      _meta: widgetMeta(widget)
    };
  }
);
```

---

## 3. 고급 기능 구현

### 3.1 위젯 간 통신

**useWidgetState를 사용한 상태 공유:**

```jsx
function WeatherWidget() {
  const [sharedState, setSharedState] = useWidgetState({
    selectedCity: null,
    favorites: []
  });

  const selectCity = (city) => {
    setSharedState(prev => ({
      ...prev,
      selectedCity: city
    }));

    // 다른 도구 호출
    window.openai.callTool('city-details', { city });
  };

  return (
    <div>
      {cities.map(city => (
        <button key={city} onClick={() => selectCity(city)}>
          {city}
        </button>
      ))}
      <p>선택된 도시: {sharedState.selectedCity}</p>
    </div>
  );
}
```

### 3.2 실시간 업데이트

**WebSocket을 사용한 실시간 데이터:**

```jsx
function LiveDataWidget() {
  const [data, setData] = useState([]);

  useEffect(() => {
    const ws = new WebSocket('wss://api.example.com/live');

    ws.onmessage = (event) => {
      const newData = JSON.parse(event.data);
      setData(prev => [...prev, newData].slice(-100)); // 최근 100개만 유지
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };

    return () => {
      ws.close();
    };
  }, []);

  return (
    <div>
      {data.map((item, index) => (
        <div key={index}>{item.value}</div>
      ))}
    </div>
  );
}
```

### 3.3 파일 업로드

```jsx
function FileUploadWidget() {
  const [file, setFile] = useState(null);
  const [uploading, setUploading] = useState(false);

  const handleFileChange = (event) => {
    setFile(event.target.files[0]);
  };

  const handleUpload = async () => {
    if (!file) return;

    setUploading(true);

    const formData = new FormData();
    formData.append('file', file);

    try {
      const response = await fetch('https://api.example.com/upload', {
        method: 'POST',
        body: formData
      });

      const result = await response.json();
      console.log('Upload success:', result);
    } catch (error) {
      console.error('Upload failed:', error);
    } finally {
      setUploading(false);
    }
  };

  return (
    <div className="p-6">
      <input
        type="file"
        onChange={handleFileChange}
        className="mb-4"
      />
      <button
        onClick={handleUpload}
        disabled={!file || uploading}
        className="px-4 py-2 bg-blue-500 text-white rounded"
      >
        {uploading ? '업로드 중...' : '업로드'}
      </button>
    </div>
  );
}
```

### 3.4 다크 모드 지원

```jsx
function ThemedWidget() {
  const theme = useOpenAiGlobal("theme");

  return (
    <div
      className={
        theme === "dark"
          ? "bg-gray-900 text-white"
          : "bg-white text-black"
      }
    >
      <h1>테마: {theme}</h1>
    </div>
  );
}
```

**Tailwind dark 모드 사용:**

```jsx
function ThemedWidget() {
  const theme = useOpenAiGlobal("theme");

  return (
    <div className={theme === "dark" ? "dark" : ""}>
      <div className="bg-white dark:bg-gray-900 text-black dark:text-white">
        <h1 className="text-2xl font-bold">제목</h1>
        <p className="text-gray-600 dark:text-gray-400">내용</p>
      </div>
    </div>
  );
}
```

---

## 4. 성능 최적화

### 4.1 번들 크기 최적화

**1. 라이브러리 선택적 임포트:**

```jsx
// ❌ 전체 라이브러리 임포트
import lodash from 'lodash';

// ✅ 필요한 함수만 임포트
import debounce from 'lodash/debounce';
import throttle from 'lodash/throttle';
```

**2. 동적 임포트:**

```jsx
function HeavyComponent() {
  const [Component, setComponent] = useState(null);

  useEffect(() => {
    // 필요할 때만 로드
    import('./HeavyFeature').then(module => {
      setComponent(() => module.default);
    });
  }, []);

  if (!Component) {
    return <div>Loading...</div>;
  }

  return <Component />;
}
```

**3. 이미지 최적화:**

```jsx
// WebP 사용
<img
  src="image.webp"
  alt="optimized"
  loading="lazy"  // 지연 로딩
  width={800}
  height={600}
/>

// srcset 사용
<img
  src="image-800.jpg"
  srcSet="
    image-400.jpg 400w,
    image-800.jpg 800w,
    image-1200.jpg 1200w
  "
  sizes="(max-width: 600px) 400px, 800px"
  alt="responsive"
/>
```

### 4.2 렌더링 최적화

**1. React.memo:**

```jsx
const ExpensiveComponent = React.memo(function ExpensiveComponent({ data }) {
  // 복잡한 렌더링 로직
  return <div>{data.value}</div>;
});

// data가 변경되지 않으면 리렌더링 안 함
```

**2. useMemo & useCallback:**

```jsx
function OptimizedComponent({ items, filter }) {
  // 필터링 결과 캐싱
  const filteredItems = useMemo(() => {
    return items.filter(item => item.category === filter);
  }, [items, filter]);

  // 함수 캐싱
  const handleClick = useCallback((id) => {
    console.log('Clicked:', id);
  }, []);

  return (
    <div>
      {filteredItems.map(item => (
        <Item key={item.id} item={item} onClick={handleClick} />
      ))}
    </div>
  );
}
```

**3. 가상화 (Virtualization):**

```jsx
import { FixedSizeList } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

### 4.3 네트워크 최적화

**1. 요청 디바운싱:**

```jsx
import { useMemo } from 'react';
import debounce from 'lodash/debounce';

function SearchWidget() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  const debouncedSearch = useMemo(
    () => debounce(async (searchQuery) => {
      const response = await fetch(`/api/search?q=${searchQuery}`);
      const data = await response.json();
      setResults(data);
    }, 300),
    []
  );

  const handleChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };

  return (
    <div>
      <input value={query} onChange={handleChange} />
      {results.map(result => (
        <div key={result.id}>{result.name}</div>
      ))}
    </div>
  );
}
```

**2. 캐싱:**

```jsx
const cache = new Map();

async function fetchWithCache(url) {
  if (cache.has(url)) {
    return cache.get(url);
  }

  const response = await fetch(url);
  const data = await response.json();

  cache.set(url, data);
  return data;
}
```

---

## 5. 디버깅과 문제 해결

### 5.1 일반적인 문제들

**1. 위젯이 로드되지 않음**

**원인:**
- 빌드를 안 했음
- BASE_URL이 잘못됨
- MCP 서버가 실행 안 됨

**해결:**
```bash
# 1. 빌드 확인
pnpm build
ls -la assets/  # 파일이 있는지 확인

# 2. 서버 로그 확인
cd pizzaz_server_node
pnpm start
# "Pizzaz MCP server listening on..." 메시지 확인

# 3. 브라우저 콘솔 확인
# F12 → Console
# 에러 메시지 확인
```

**2. 위젯이 표시되지만 데이터가 없음**

**원인:**
- `useWidgetProps`가 null 반환
- MCP 서버가 `structuredContent` 안 보냄

**해결:**
```jsx
// 디버깅 코드 추가
function MyWidget() {
  const props = useWidgetProps({});
  console.log('Widget props:', props);  // 데이터 확인

  if (!props || Object.keys(props).length === 0) {
    return <div>데이터 없음</div>;
  }

  return <div>데이터: {JSON.stringify(props)}</div>;
}
```

**3. 스타일이 적용되지 않음**

**원인:**
- CSS 파일이 임포트 안 됨
- Tailwind 클래스가 빌드에 포함 안 됨

**해결:**
```jsx
// CSS 임포트 확인
import './my-widget.css';

// Tailwind 클래스 사용 확인
<div className="flex items-center gap-3">
  {/* content */}
</div>
```

### 5.2 디버깅 도구

**1. React DevTools:**
```bash
# Chrome Extension 설치
# "React Developer Tools"

# 브라우저에서:
# F12 → Components 탭
# → 컴포넌트 트리 확인
# → Props, State 확인
```

**2. Network 탭 활용:**
```
F12 → Network 탭
→ XHR/Fetch 필터
→ MCP 요청/응답 확인
→ Response 본문 확인
```

**3. 로깅 추가:**
```jsx
function MyWidget() {
  const props = useWidgetProps({});

  useEffect(() => {
    console.group('MyWidget Mounted');
    console.log('Props:', props);
    console.log('window.openai:', window.openai);
    console.groupEnd();
  }, [props]);

  // ...
}
```

### 5.3 에러 바운더리

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-6 text-center">
          <h2 className="text-xl font-bold text-red-600 mb-2">
            오류가 발생했습니다
          </h2>
          <p className="text-sm text-gray-600">
            {this.state.error?.message}
          </p>
          <button
            onClick={() => window.location.reload()}
            className="mt-4 px-4 py-2 bg-blue-500 text-white rounded"
          >
            새로고침
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// 사용
createRoot(document.getElementById('root')).render(
  <ErrorBoundary>
    <MyWidget />
  </ErrorBoundary>
);
```

---

## 6. 배포 체크리스트

### 6.1 배포 전 확인사항

**✅ 코드 품질**
- [ ] TypeScript 에러 없음 (`pnpm tsc`)
- [ ] ESLint 경고 없음
- [ ] 사용하지 않는 코드 제거
- [ ] console.log 제거 또는 환경별 분리

**✅ 빌드**
- [ ] `pnpm build` 성공
- [ ] assets/ 폴더에 파일 생성 확인
- [ ] 번들 크기 확인 (< 1MB 권장)
- [ ] BASE_URL 환경 변수 설정

**✅ 테스트**
- [ ] 모든 위젯이 로드되는지 확인
- [ ] 데이터가 올바르게 표시되는지 확인
- [ ] 인터랙션이 정상 작동하는지 확인
- [ ] 다양한 브라우저에서 테스트
- [ ] 모바일 환경 테스트

**✅ 성능**
- [ ] 초기 로딩 시간 < 3초
- [ ] 번들 크기 최적화
- [ ] 이미지 최적화 (WebP, 적절한 크기)
- [ ] 불필요한 리렌더링 제거

**✅ 보안**
- [ ] API 키 환경 변수로 관리
- [ ] CORS 설정 검토
- [ ] XSS 방지 (사용자 입력 검증)
- [ ] HTTPS 사용

**✅ 접근성**
- [ ] 키보드 네비게이션 가능
- [ ] ARIA 속성 추가
- [ ] 색상 대비 적절 (4.5:1 이상)
- [ ] 스크린 리더 테스트

### 6.2 배포 스크립트

**package.json에 스크립트 추가:**
```json
{
  "scripts": {
    "build": "tsx ./build-all.mts",
    "build:prod": "BASE_URL=https://cdn.example.com pnpm build",
    "deploy:assets": "aws s3 sync assets/ s3://my-bucket/widgets/",
    "deploy:server": "cd pizzaz_server_node && npm run deploy",
    "deploy": "pnpm build:prod && pnpm deploy:assets && pnpm deploy:server"
  }
}
```

**배포 실행:**
```bash
# 한 번에 배포
pnpm deploy

# 또는 단계별
pnpm build:prod
pnpm deploy:assets
pnpm deploy:server
```

### 6.3 환경별 설정

**.env 파일 예제:**
```bash
# .env.development
BASE_URL=http://localhost:4444
MCP_SERVER_URL=http://localhost:8000
API_KEY=dev_api_key

# .env.production
BASE_URL=https://cdn.example.com
MCP_SERVER_URL=https://api.example.com
API_KEY=prod_api_key
```

**환경별 빌드:**
```bash
# 개발
NODE_ENV=development pnpm build

# 프로덕션
NODE_ENV=production pnpm build
```

---

## 7. 추가 학습 리소스

### 7.1 공식 문서

**React:**
- https://react.dev - 공식 문서
- https://react.dev/learn - 튜토리얼

**TypeScript:**
- https://www.typescriptlang.org/docs - 공식 문서
- https://www.typescriptlang.org/play - 온라인 플레이그라운드

**Vite:**
- https://vitejs.dev/guide - 시작 가이드
- https://vitejs.dev/config - 설정 레퍼런스

**MCP:**
- https://modelcontextprotocol.io - MCP 프로토콜 스펙
- https://github.com/modelcontextprotocol - 공식 GitHub

### 7.2 유용한 라이브러리

**UI 컴포넌트:**
- Radix UI - https://www.radix-ui.com
- shadcn/ui - https://ui.shadcn.com
- Headless UI - https://headlessui.com

**애니메이션:**
- Framer Motion - https://www.framer.com/motion
- React Spring - https://www.react-spring.dev

**데이터 시각화:**
- Chart.js - https://www.chartjs.org
- D3.js - https://d3js.org
- Recharts - https://recharts.org

**지도:**
- Mapbox GL JS - https://docs.mapbox.com
- Leaflet - https://leafletjs.com

**3D 그래픽:**
- Three.js - https://threejs.org
- React Three Fiber - https://docs.pmnd.rs/react-three-fiber

### 7.3 커뮤니티

**Discord:**
- React Discord
- TypeScript Discord

**GitHub:**
- openai/openai-apps-sdk-examples
- modelcontextprotocol

**Stack Overflow:**
- [react] 태그
- [typescript] 태그
- [vite] 태그

---

## 💡 최종 요약

### 새 위젯 만들기
1. `src/[widget-name]/` 디렉토리 생성
2. `index.jsx` 작성
3. MCP 서버에 도구 추가
4. 빌드 및 테스트

### 데이터 연동
- **API**: fetch 또는 axios 사용
- **데이터베이스**: MCP 서버에서 처리
- **실시간**: WebSocket 활용

### 고급 기능
- **위젯 간 통신**: useWidgetState
- **실시간 업데이트**: WebSocket
- **다크 모드**: useOpenAiGlobal("theme")

### 성능 최적화
- **번들 크기**: 선택적 임포트, 동적 로딩
- **렌더링**: React.memo, useMemo, useCallback
- **네트워크**: 디바운싱, 캐싱

### 디버깅
- React DevTools
- Network 탭
- 로깅
- 에러 바운더리

### 배포
- 체크리스트 확인
- 환경 변수 설정
- 빌드 및 배포 스크립트 실행

---

**🎉 전체 학습 가이드 완료!**

이제 OpenAI Apps SDK를 사용해서 멋진 위젯을 만들 준비가 되었습니다!

**다음 단계:**
1. 작은 위젯부터 시작해보세요
2. 기존 예제를 수정해보세요
3. 본인만의 위젯을 만들어보세요
4. 커뮤니티에 공유해보세요!

**행운을 빕니다! 🚀**
