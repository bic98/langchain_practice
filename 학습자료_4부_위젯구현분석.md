# OpenAI Apps SDK 완벽 학습 가이드 - 4부: 위젯 구현 분석

## 📚 목차
1. [Pizzaz 지도 위젯 완전 분석](#1-pizzaz-지도-위젯-완전-분석)
2. [Todo 리스트 위젯 완전 분석](#2-todo-리스트-위젯-완전-분석)
3. [Solar System 3D 위젯 완전 분석](#3-solar-system-3d-위젯-완전-분석)
4. [공통 패턴과 베스트 프랙티스](#4-공통-패턴과-베스트-프랙티스)
5. [애니메이션과 인터랙션](#5-애니메이션과-인터랙션)

---

## 1. Pizzaz 지도 위젯 완전 분석

### 1.1 전체 구조

**파일 구성:**
```
src/pizzaz/
├── index.jsx           # 메인 컴포넌트
├── Inspector.jsx       # 장소 상세 패널
├── Sidebar.jsx         # 사이드바 목록
├── markers.json        # 장소 데이터
└── map.css            # 지도 스타일
```

**컴포넌트 계층:**
```
App (메인 컨테이너)
├── Sidebar (장소 목록)
│   └── PlaceListItem (개별 장소)
├── Inspector (선택된 장소 상세)
└── Map (Mapbox 지도)
    └── Markers (지도 마커들)
```

### 1.2 Mapbox 초기화

**Mapbox란?**
- 인터랙티브 지도를 만드는 JavaScript 라이브러리
- Google Maps의 대안
- 커스터마이징 자유도가 높음

**초기화 코드:**
```jsx
import mapboxgl from "mapbox-gl";
import "mapbox-gl/dist/mapbox-gl.css";

// 1. API 토큰 설정
mapboxgl.accessToken = "pk.eyJ1IjoiZXJpY25pbmciLCJhIjoiY21icXlubWM1MDRiczJvb2xwM2p0amNyayJ9...";

function App() {
  const mapRef = useRef(null);      // DOM 참조
  const mapObj = useRef(null);      // Mapbox 인스턴스
  const markerObjs = useRef([]);    // 마커 배열

  useEffect(() => {
    // 이미 생성되었으면 중단
    if (mapObj.current) return;

    // 2. Mapbox 지도 생성
    mapObj.current = new mapboxgl.Map({
      container: mapRef.current,                    // 렌더링할 DOM 요소
      style: "mapbox://styles/mapbox/streets-v12", // 지도 스타일
      center: markerCoords[0],                      // 초기 중심점 [경도, 위도]
      zoom: 12,                                     // 초기 줌 레벨
      attributionControl: false                     // 속성 컨트롤 숨김
    });

    // 3. 마커 추가
    addAllMarkers(places);

    // 4. 지도를 마커에 맞춰 조정
    setTimeout(() => {
      fitMapToMarkers(mapObj.current, markerCoords);
    }, 0);

    // 5. 리사이즈 처리
    requestAnimationFrame(() => mapObj.current.resize());
    window.addEventListener("resize", mapObj.current.resize);

    // 6. 클린업
    return () => {
      window.removeEventListener("resize", mapObj.current.resize);
      mapObj.current.remove();
    };
  }, []); // 빈 배열 - 한 번만 실행

  return <div ref={mapRef} />;
}
```

**왜 useRef를 사용하나?**

```jsx
// ❌ useState 사용 시
const [map, setMap] = useState(null);

useEffect(() => {
  const newMap = new mapboxgl.Map({ ... });
  setMap(newMap);  // 상태 업데이트 → 리렌더링!
}, []);

// 문제: 리렌더링될 때마다 지도가 새로 생성될 수 있음

// ✅ useRef 사용 시
const mapObj = useRef(null);

useEffect(() => {
  mapObj.current = new mapboxgl.Map({ ... });
  // 리렌더링 없음 - 안전!
}, []);
```

### 1.3 마커 추가하기

```jsx
function addAllMarkers(placesList) {
  // 기존 마커 제거
  markerObjs.current.forEach(m => m.remove());
  markerObjs.current = [];

  placesList.forEach(place => {
    // 마커 생성
    const marker = new mapboxgl.Marker({
      color: "#F46C21"  // 주황색
    })
      .setLngLat(place.coords)      // 위치 설정
      .addTo(mapObj.current);       // 지도에 추가

    // 마커 클릭 이벤트
    const el = marker.getElement();
    if (el) {
      el.style.cursor = "pointer";
      el.addEventListener("click", () => {
        navigate(`/place/${place.id}`);
        panTo(place.coords, { offsetForInspector: true });
      });
    }

    markerObjs.current.push(marker);
  });
}
```

**Marker 옵션:**
```javascript
new mapboxgl.Marker({
  color: "#F46C21",           // 마커 색상
  draggable: false,           // 드래그 가능 여부
  rotation: 0,                // 회전 각도
  pitchAlignment: "viewport", // 기울기 정렬
  scale: 1.0                  // 크기
})
```

### 1.4 지도 이동 (Pan & Zoom)

**fitMapToMarkers - 모든 마커가 보이도록 조정:**
```jsx
function fitMapToMarkers(map, coords) {
  if (!map || !coords.length) return;

  // 마커가 하나만 있으면 해당 위치로 이동
  if (coords.length === 1) {
    map.flyTo({ center: coords[0], zoom: 12 });
    return;
  }

  // 여러 마커 - 모두 포함하는 영역 계산
  const bounds = coords.reduce(
    (b, c) => b.extend(c),
    new mapboxgl.LngLatBounds(coords[0], coords[0])
  );

  // 영역에 맞춰 지도 조정
  map.fitBounds(bounds, {
    padding: 60,        // 가장자리 여백
    animate: true       // 애니메이션
  });
}
```

**panTo - 특정 위치로 부드럽게 이동:**
```jsx
function panTo(coord, { offsetForInspector } = {}) {
  if (!mapObj.current) return;

  // Inspector가 열려있으면 오프셋 적용
  const inspectorOffset = offsetForInspector ? getInspectorOffsetPx() : 0;

  const flyOpts = {
    center: coord,
    zoom: 14,
    speed: 1.2,        // 이동 속도
    curve: 1.6         // 이동 곡선
  };

  if (inspectorOffset) {
    flyOpts.offset = [inspectorOffset, 0];
  }

  mapObj.current.flyTo(flyOpts);
}
```

**왜 오프셋이 필요한가?**
```
┌────────────────────────────────────────┐
│  Sidebar  │  Map Area  │  Inspector   │
│           │            │              │
│  Places   │    🗺️      │  Details     │
│  List     │   📍 ←─────┼─ Offset!    │
│           │            │              │
└────────────────────────────────────────┘
```

Inspector가 열리면 마커가 가려질 수 있음 → 오프셋을 줘서 중앙에 보이게!

### 1.5 React Router 통합

**URL 구조:**
```
/                    → 지도만 표시
/place/1             → 장소 1 선택 + Inspector 표시
/place/2             → 장소 2 선택 + Inspector 표시
```

**라우팅 설정:**
```jsx
function RouterRoot() {
  return (
    <Routes>
      <Route path="*" element={<App />}>
        <Route path="place/:placeId" element={<></>} />
      </Route>
    </Routes>
  );
}

createRoot(document.getElementById("pizzaz-root")).render(
  <BrowserRouter>
    <RouterRoot />
  </BrowserRouter>
);
```

**URL에서 선택된 장소 추출:**
```jsx
const location = useLocation();

const selectedId = React.useMemo(() => {
  // URL: /place/123 → "123" 추출
  const match = location?.pathname?.match(/(?:^|\/)place\/([^/]+)/);
  return match && match[1] ? match[1] : null;
}, [location?.pathname]);

const selectedPlace = places.find(p => p.id === selectedId) || null;
```

**장소 선택 시 URL 변경:**
```jsx
const navigate = useNavigate();

function handlePlaceClick(place) {
  navigate(`/place/${place.id}`);
  panTo(place.coords, { offsetForInspector: true });
}
```

### 1.6 DisplayMode에 따른 레이아웃

```jsx
const displayMode = useOpenAiGlobal("displayMode");
const maxHeight = useMaxHeight() ?? undefined;

return (
  <div
    style={{
      maxHeight,
      height: displayMode === "fullscreen" ? maxHeight - 40 : 480
    }}
    className={
      displayMode === "fullscreen"
        ? "rounded-none border-0"
        : "border border-black/10 rounded-2xl sm:rounded-3xl"
    }
  >
    {/* Sidebar - 항상 표시 */}
    <Sidebar places={places} selectedId={selectedId} onSelect={handleSelect} />

    {/* Inspector - fullscreen일 때만 표시 */}
    <AnimatePresence>
      {displayMode === "fullscreen" && selectedPlace && (
        <Inspector place={selectedPlace} onClose={() => navigate("..")} />
      )}
    </AnimatePresence>

    {/* Map */}
    <div ref={mapRef} />

    {/* 전체화면 버튼 - inline/pip일 때만 표시 */}
    {displayMode !== "fullscreen" && (
      <button onClick={() => {
        window.webplus.requestDisplayMode({ mode: "fullscreen" });
      }}>
        <Maximize2 />
      </button>
    )}
  </div>
);
```

### 1.7 Sidebar 컴포넌트 상세

**데스크톱 레이아웃:**
```jsx
// src/pizzaz/Sidebar.jsx
export default function Sidebar({ places, selectedId, onSelect }) {
  const displayMode = useOpenAiGlobal("displayMode");
  const forceMobile = displayMode !== "fullscreen";

  return (
    <>
      {/* 데스크톱 - 왼쪽 사이드바 */}
      <div className={forceMobile ? "hidden" : ""}>
        <div className="absolute inset-y-0 left-0 w-[340px] overflow-y-auto">
          <div className="sticky top-0 bg-white">
            {places.length} results
          </div>
          {places.map(place => (
            <PlaceListItem
              key={place.id}
              place={place}
              isSelected={selectedId === place.id}
              onClick={() => onSelect(place)}
            />
          ))}
        </div>
      </div>

      {/* 모바일 - 하단 캐러셀 */}
      <div className={forceMobile ? "" : "hidden"}>
        <div className="absolute inset-x-0 bottom-0">
          <div className="overflow-hidden" ref={emblaRef}>
            <div className="flex gap-3">
              {places.map(place => (
                <PlaceListItem key={place.id} place={place} />
              ))}
            </div>
          </div>
        </div>
      </div>
    </>
  );
}
```

**Embla Carousel 사용:**
```jsx
import useEmblaCarousel from "embla-carousel-react";

function Sidebar() {
  const [emblaRef] = useEmblaCarousel({
    dragFree: true,  // 자유롭게 드래그
    loop: false      // 무한 루프 비활성화
  });

  return (
    <div ref={emblaRef}>
      <div className="flex gap-3">
        {/* 아이템들 */}
      </div>
    </div>
  );
}
```

### 1.8 Inspector 애니메이션

```jsx
// src/pizzaz/Inspector.jsx
import { motion, AnimatePresence } from "framer-motion";

function Inspector({ place, onClose }) {
  return (
    <motion.div
      initial={{ opacity: 0, x: 100 }}      // 시작: 투명, 오른쪽
      animate={{ opacity: 1, x: 0 }}         // 종료: 불투명, 제자리
      exit={{ opacity: 0, x: 100 }}          // 사라질 때: 투명, 오른쪽
      transition={{
        type: "spring",
        bounce: 0.2,
        duration: 0.5
      }}
      className="absolute right-0 top-0 w-96 h-full bg-white"
    >
      <button onClick={onClose}>닫기</button>
      <h2>{place.name}</h2>
      <p>{place.description}</p>
      <img src={place.image} alt={place.name} />
    </motion.div>
  );
}
```

---

## 2. Todo 리스트 위젯 완전 분석

### 2.1 전체 구조

**상태 관리 구조:**
```javascript
const [data, setData] = useState({
  lists: [
    {
      id: "list1",
      title: "개인 할 일",
      todos: [
        { id: "todo1", title: "운동하기", isComplete: false, note: "", dueDate: "2024-12-31" },
        { id: "todo2", title: "책 읽기", isComplete: true, note: "30분", dueDate: null }
      ]
    },
    {
      id: "list2",
      title: "업무",
      todos: [...]
    }
  ]
});
```

**화면 구성:**
```
┌────────────────────────────────────────┐
│  ┌─ My Lists ────────────────────────┐ │
│  │  📋 개인 할 일                     │ │
│  │  💼 업무                          │ │
│  │  🏠 집안일                        │ │
│  └───────────────────────────────────┘ │
└────────────────────────────────────────┘
         ↓ 리스트 클릭
┌────────────────────────────────────────┐
│  ← 개인 할 일                    + ✓   │
│  ┌───────────────────────────────────┐ │
│  │ ○ 운동하기              📅 12/31 │ │
│  │ ● 책 읽기 (완료)                 │ │
│  │ ○ 물 마시기                      │ │
│  └───────────────────────────────────┘ │
└────────────────────────────────────────┘
```

### 2.2 불변성 유지 패턴

**React에서 왜 불변성이 중요한가?**

```jsx
// ❌ 나쁜 예 - 직접 수정
function badAddTodo() {
  data.lists[0].todos.push(newTodo);  // 배열 직접 수정
  setData(data);  // React는 같은 객체라고 판단 → 리렌더링 안 됨!
}

// ✅ 좋은 예 - 새 객체 생성
function goodAddTodo() {
  setData(prev => {
    const lists = prev.lists.slice();     // 배열 복사
    const list = { ...lists[0] };         // 객체 복사
    list.todos = [newTodo, ...list.todos]; // 새 배열
    lists[0] = list;
    return { lists };  // 새 객체 반환
  });
}
```

**실제 구현 - Todo 추가:**
```jsx
const addTodo = () => {
  if (currentList == null) return;

  const newId = uid();  // 고유 ID 생성

  setData(prev => {
    const lists = prev.lists.slice();           // 1. lists 배열 복사
    const listIdx = currentTodoList;
    const list = { ...lists[listIdx] };         // 2. list 객체 복사
    list.todos = [                              // 3. todos 배열 교체
      { id: newId, title: "", isComplete: false, note: "", dueDate: null },
      ...list.todos
    ];
    lists[listIdx] = list;                      // 4. lists 배열에 업데이트
    return { lists };                           // 5. 새 data 객체 반환
  });
};
```

**실제 구현 - Todo 업데이트:**
```jsx
const updateItemById = (id, val) => {
  setData(prev => {
    const lists = prev.lists.slice();
    const list = { ...lists[listIdx] };
    list.todos = list.todos.map(t =>
      t.id === id ? { ...t, ...val } : t  // 해당 todo만 업데이트
    );
    lists[listIdx] = list;
    return { lists };
  });
};

// 사용:
updateItemById("todo1", { isComplete: true });
updateItemById("todo2", { title: "새 제목" });
updateItemById("todo3", { dueDate: "2024-12-31" });
```

### 2.3 Framer Motion 드래그 앤 드롭

**Reorder 컴포넌트:**
```jsx
import { Reorder } from "framer-motion";

function TodoList({ items }) {
  const itemIds = useMemo(() => items.map(t => t.id), [items]);

  return (
    <Reorder.Group
      axis="y"              // 수직 드래그
      values={itemIds}      // 현재 순서 (ID 배열)
      onReorder={setItemsByOrder}  // 순서 변경 콜백
    >
      {items.map(item => (
        <Reorder.Item
          key={item.id}
          value={item.id}
          dragListener={false}    // 자동 드래그 비활성화
          dragControls={controls} // 커스텀 드래그 컨트롤
        >
          <TodoListItem item={item} />
        </Reorder.Item>
      ))}
    </Reorder.Group>
  );
}
```

**왜 ID 배열을 사용하나?**

```jsx
// ❌ 객체 배열 사용 시
<Reorder.Group values={items} onReorder={setItems}>
  {/* 문제: 객체가 크면 성능 저하 */}

// ✅ ID 배열 사용 시
<Reorder.Group values={itemIds} onReorder={setItemsByOrder}>
  {/* ID만 전달 → 가볍고 빠름 */}
```

**커스텀 드래그 핸들:**
```jsx
function TodoListItem({ item }) {
  const controls = useDragControls();

  // 드래그 vs 클릭 구분
  const dragStartedRef = useRef(false);
  const pointerDownPosRef = useRef(null);
  const POINTER_THRESHOLD = 4; // px

  const onEllipsisPointerDown = (e) => {
    e.stopPropagation();
    pointerDownPosRef.current = { x: e.clientX, y: e.clientY };
    dragStartedRef.current = false;
  };

  const onEllipsisPointerMove = (e) => {
    if (!pointerDownPosRef.current || dragStartedRef.current) return;

    const dx = e.clientX - pointerDownPosRef.current.x;
    const dy = e.clientY - pointerDownPosRef.current.y;

    if (Math.hypot(dx, dy) >= POINTER_THRESHOLD) {
      dragStartedRef.current = true;
      controls.start(e);  // 드래그 시작
    }
  };

  const onEllipsisPointerUp = (e) => {
    if (!dragStartedRef.current) {
      setMenuOpen(true);  // 클릭으로 판단 → 메뉴 열기
    }
  };

  return (
    <Reorder.Item dragControls={controls}>
      <button
        onPointerDown={onEllipsisPointerDown}
        onPointerMove={onEllipsisPointerMove}
        onPointerUp={onEllipsisPointerUp}
      >
        <EllipsisVertical />
      </button>
    </Reorder.Item>
  );
}
```

### 2.4 React DatePicker 통합

**DatePicker 스타일 주입:**
```jsx
function injectDatepickerStylesOnce() {
  if (__datepickerStylesInjected) return;
  __datepickerStylesInjected = true;

  const css = `
    .react-datepicker {
      font-family: ui-sans-serif, system-ui;
      font-size: 12px;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 10px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.10);
    }
    /* ... 더 많은 스타일 */
  `;

  const style = document.createElement("style");
  style.textContent = css;
  document.head.appendChild(style);
}

useEffect(() => {
  injectDatepickerStylesOnce();
}, []);
```

**DatePicker 사용:**
```jsx
import DatePicker from "react-datepicker";

function TodoListItem({ item, updateItemById }) {
  const datepickerRef = useRef(null);

  // YYYY-MM-DD ↔ Date 객체 변환
  const selectedDate = parseYMD(item.dueDate);  // "2024-12-31" → Date

  const handleDateChange = (date) => {
    const ymd = toYMD(date);  // Date → "2024-12-31"
    updateItemById(item.id, { dueDate: ymd });
  };

  return (
    <DatePicker
      ref={datepickerRef}
      selected={selectedDate}
      onChange={handleDateChange}
      dateFormat="yyyy-MM-dd"
      customInput={<HiddenAnchorInput />}
      popperPlacement="bottom-start"
      renderCustomHeader={renderHeader}  // 커스텀 헤더
    />
  );
}
```

**커스텀 헤더 (Prev | 월 년도 | Next):**
```jsx
const renderHeader = ({
  date,
  decreaseMonth,
  increaseMonth,
  prevMonthButtonDisabled,
  nextMonthButtonDisabled
}) => {
  return (
    <div className="flex items-center justify-center">
      <button onClick={decreaseMonth} disabled={prevMonthButtonDisabled}>
        Prev
      </button>
      <div className="font-semibold">
        {date.toLocaleDateString(undefined, { month: "long", year: "numeric" })}
      </div>
      <button onClick={increaseMonth} disabled={nextMonthButtonDisabled}>
        Next
      </button>
    </div>
  );
};
```

### 2.5 Zoom 애니메이션

**ZoomViewer - 리스트에서 상세로 확대:**
```jsx
function ZoomViewer({ origin, containerRef, children }) {
  // 시작 위치 계산
  const originRect = getRelativePosition(
    origin.current.getBoundingClientRect(),
    containerRef.current.getBoundingClientRect()
  );

  const initial = {
    left: originRect.left,
    top: originRect.top,
    width: originRect.width,
    height: originRect.height
  };

  const animate = {
    left: 0,
    top: 0,
    width: "100%",
    height: "100%"
  };

  return (
    <motion.div
      initial={initial}       // 작은 상자에서 시작
      animate={animate}       // 전체 화면으로 확대
      exit={initial}          // 다시 작은 상자로 축소
      transition={{
        type: "spring",
        bounce: 0.16,
        duration: 0.56
      }}
    >
      {children}
    </motion.div>
  );
}
```

**사용:**
```jsx
function App() {
  const rowRefs = useRef({});  // 각 리스트 행의 ref 저장

  return (
    <AnimatePresence mode="popLayout">
      {currentList != null && currentTodoListRef ? (
        <ZoomViewer origin={currentTodoListRef} containerRef={containerRef}>
          <TodoList list={currentList} />
        </ZoomViewer>
      ) : (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          {/* 리스트 목록 */}
        </motion.div>
      )}
    </AnimatePresence>
  );
}
```

### 2.6 CircleCheckbox 커스텀 컴포넌트

```jsx
function CircleCheckbox({ checked, onToggle, label }) {
  return (
    <div
      role="checkbox"
      aria-checked={checked}
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === " " || e.key === "Enter") {
          e.preventDefault();
          onToggle();
        }
      }}
      onClick={(e) => {
        e.stopPropagation();
        onToggle();
      }}
      className="w-4 h-4 rounded-full border cursor-pointer"
      aria-label={label}
    >
      <AnimatePresence initial={false}>
        {checked && (
          <motion.div
            initial={{ scale: 0.6, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.6, opacity: 0 }}
            transition={{ type: "spring", bounce: 0.3, duration: 0.28 }}
            className="rounded-full bg-black w-[11.5px] h-[11.5px]"
          />
        )}
      </AnimatePresence>
    </div>
  );
}
```

**접근성 고려:**
- `role="checkbox"` - 스크린 리더에 체크박스임을 알림
- `aria-checked` - 체크 상태 전달
- `tabIndex={0}` - 키보드 포커스 가능
- `onKeyDown` - 스페이스바/엔터로도 토글

---

## 3. Solar System 3D 위젯 완전 분석

### 3.1 Three.js와 React Three Fiber

**Three.js란?**
- 웹에서 3D 그래픽을 만드는 JavaScript 라이브러리
- WebGL을 쉽게 사용할 수 있게 함

**React Three Fiber란?**
- Three.js를 React 컴포넌트처럼 사용할 수 있게 하는 라이브러리

**기본 구조:**
```jsx
import { Canvas } from "@react-three/fiber";

function SolarSystem() {
  return (
    <Canvas camera={{ position: [0, 2, 8], fov: 60 }}>
      {/* 3D 씬 내용 */}
      <ambientLight intensity={0.135} />
      <pointLight position={[0, 0, 0]} intensity={18} />
      <Sun />
      <Planet name="Earth" />
    </Canvas>
  );
}
```

**Canvas 컴포넌트:**
- Three.js Scene, Camera, Renderer를 자동으로 설정
- `camera` prop으로 카메라 위치와 시야각 설정

### 3.2 행성 컴포넌트

```jsx
function Planet({ name, radius, size, speed, isOrbiting, onPlanetClick, ref }) {
  const SPEED_SCALE = 0.2;
  const mesh = useRef();
  const theta = useRef(Math.random() * Math.PI * 2);  // 초기 각도

  // 부모에서 위치를 가져올 수 있도록
  useImperativeHandle(ref, () => ({
    getPosition: () => mesh.current.position.clone()
  }));

  // 텍스처 로드
  const texture = useLoader(
    THREE.TextureLoader,
    `https://persistent.oaistatic.com/ecosys/${name.toLowerCase()}_2k.webp`
  );

  // 애니메이션 - 매 프레임 실행
  useFrame(() => {
    if (isOrbiting) {
      theta.current += speed * SPEED_SCALE;
      const x = radius * Math.cos(theta.current);
      const z = radius * Math.sin(theta.current);
      mesh.current.position.set(x, 0, z);
    }
  });

  return (
    <mesh
      ref={mesh}
      onClick={(e) => {
        e.stopPropagation();
        onPlanetClick(mesh.current.position.clone());
      }}
    >
      <sphereGeometry args={[size, 32, 32]} />
      <meshStandardMaterial map={texture} />
      {name === "Saturn" && <SaturnRing planetSize={size} />}
    </mesh>
  );
}
```

**Three.js 객체를 React로:**
```jsx
// Three.js 방식
const geometry = new THREE.SphereGeometry(1, 32, 32);
const material = new THREE.MeshStandardMaterial({ map: texture });
const mesh = new THREE.Mesh(geometry, material);

// React Three Fiber 방식
<mesh>
  <sphereGeometry args={[1, 32, 32]} />
  <meshStandardMaterial map={texture} />
</mesh>
```

### 3.3 useFrame - 애니메이션 루프

```jsx
import { useFrame } from "@react-three/fiber";

function Planet() {
  const mesh = useRef();
  const theta = useRef(0);

  useFrame((state, delta) => {
    // state: { clock, camera, scene, gl, ... }
    // delta: 이전 프레임과의 시간 차이 (초)

    theta.current += 0.01;
    const x = 5 * Math.cos(theta.current);
    const z = 5 * Math.sin(theta.current);
    mesh.current.position.set(x, 0, z);

    // 회전도 추가
    mesh.current.rotation.y += 0.01;
  });

  return <mesh ref={mesh}>...</mesh>;
}
```

**왜 useFrame을 사용하나?**

```jsx
// ❌ setInterval 사용 시
useEffect(() => {
  const timer = setInterval(() => {
    // 문제 1: React 상태 업데이트 → 불필요한 리렌더링
    // 문제 2: 60fps에 맞춰지지 않음
    // 문제 3: 탭이 비활성화되어도 실행
  }, 16);
}, []);

// ✅ useFrame 사용 시
useFrame(() => {
  // 브라우저의 requestAnimationFrame 사용
  // 60fps에 자동으로 맞춰짐
  // 탭이 비활성화되면 자동 일시정지
  // React 리렌더링 없음
});
```

### 3.4 OrbitControls - 카메라 컨트롤

```jsx
import { OrbitControls } from "@react-three/drei";

function SolarSystem() {
  const orbitControlsRef = useRef();

  return (
    <Canvas>
      <OrbitControls
        ref={orbitControlsRef}
        enableDamping={true}        // 부드러운 감속
        dampingFactor={0.05}
        minDistance={5}             // 최소 줌 거리
        maxDistance={50}            // 최대 줌 거리
        enablePan={true}            // 패닝 허용
        enableZoom={true}           // 줌 허용
        enableRotate={true}         // 회전 허용
      />
      {/* ... */}
    </Canvas>
  );
}
```

**OrbitControls 기능:**
- 마우스 드래그 → 카메라 회전
- 마우스 휠 → 줌 인/아웃
- 오른쪽 클릭 드래그 → 패닝

### 3.5 카메라 애니메이션

**Lerp (Linear Interpolation) - 부드러운 이동:**
```jsx
function CameraController({ targetPosition, orbitControlsRef }) {
  const { camera } = useThree();
  const targetCamPos = useRef(null);
  const targetCamFocus = useRef(null);

  useEffect(() => {
    if (!targetPosition) return;

    // 목표 위치 설정
    const offset = new THREE.Vector3()
      .subVectors(camera.position, targetPosition)
      .normalize()
      .multiplyScalar(2);  // 행성에서 2 단위 떨어진 곳

    targetCamPos.current = targetPosition.clone().add(offset);
    targetCamFocus.current = targetPosition.clone();

    // 사용자 조작 비활성화
    if (orbitControlsRef.current) {
      orbitControlsRef.current.enabled = false;
    }
  }, [targetPosition]);

  useFrame(() => {
    if (!targetCamPos.current || !targetCamFocus.current) return;

    const lerpSpeed = 0.04;  // 보간 속도 (작을수록 느림)

    // 카메라 위치 보간
    camera.position.lerp(targetCamPos.current, lerpSpeed);

    // OrbitControls 타겟 보간
    if (orbitControlsRef.current) {
      orbitControlsRef.current.target.lerp(targetCamFocus.current, lerpSpeed);
      orbitControlsRef.current.update();
    }

    // 목표에 거의 도달했으면 종료
    if (
      camera.position.distanceTo(targetCamPos.current) < 0.05 &&
      orbitControlsRef.current.target.distanceTo(targetCamFocus.current) < 0.05
    ) {
      targetCamPos.current = null;
      targetCamFocus.current = null;
      orbitControlsRef.current.enabled = true;  // 조작 다시 활성화
    }
  });

  return null;
}
```

**lerp 함수란?**
```javascript
// 선형 보간: a에서 b로 t만큼 이동
function lerp(a, b, t) {
  return a + (b - a) * t;
}

// 예:
lerp(0, 10, 0.5);   // 5 (중간)
lerp(0, 10, 0.1);   // 1 (10% 이동)
lerp(0, 10, 0.9);   // 9 (90% 이동)
```

**왜 매 프레임 lerp를 하나?**
```javascript
// 첫 프레임
position = 0
target = 10
position = lerp(0, 10, 0.1) = 1

// 두 번째 프레임
position = 1
target = 10
position = lerp(1, 10, 0.1) = 1.9

// 세 번째 프레임
position = 1.9
target = 10
position = lerp(1.9, 10, 0.1) = 2.71

// ... 점점 느리게 접근 (감속 효과)
```

### 3.6 Post-Processing Effects

**EffectComposer - 후처리 효과:**
```jsx
import { EffectComposer, Bloom, DepthOfField } from "@react-three/postprocessing";

function Effects({ focusTarget, hasFocus }) {
  const { camera } = useThree();
  const depthOfFieldRef = useRef();

  useFrame(() => {
    if (!depthOfFieldRef.current) return;

    if (!hasFocus) {
      depthOfFieldRef.current.bokehScale = 0;  // 블러 없음
      return;
    }

    // 거리에 따라 블러 강도 조절
    const d = camera.position.distanceTo(focusTarget);
    const scale = THREE.MathUtils.clamp(12 - d * 0.75, 0, 12);
    depthOfFieldRef.current.bokehScale = scale;
  });

  return (
    <EffectComposer>
      {/* Depth of Field - 피사계 심도 (배경 흐리기) */}
      <DepthOfField
        ref={depthOfFieldRef}
        focusDistance={0}
        focalLength={0.02}
        height={480}
        bokehScale={0}
        target={focusTarget}
      />

      {/* Bloom - 밝은 부분 빛나게 */}
      <Bloom
        luminanceThreshold={0}
        luminanceSmoothing={0.25}
        intensity={1.75}
        mipmapBlur
      />
    </EffectComposer>
  );
}
```

**효과 예시:**
```
Depth of Field (피사계 심도):
┌────────────────────────────────┐
│  [흐림]  🌍 Earth [선명]  [흐림] │
│  Mars            Jupiter        │
└────────────────────────────────┘

Bloom (글로우):
┌────────────────────────────────┐
│      ☀️ Sun (빛남)              │
│     💫 Stars (반짝임)            │
└────────────────────────────────┘
```

### 3.7 배경 텍스처

```jsx
import { useThree, useLoader } from "@react-three/fiber";
import * as THREE from "three";

function SceneBackground() {
  const { scene } = useThree();

  const texture = useLoader(
    THREE.TextureLoader,
    "https://persistent.oaistatic.com/ecosys/stars_8k.webp"
  );

  useEffect(() => {
    // Equirectangular (360도 파노라마) 매핑
    texture.mapping = THREE.EquirectangularReflectionMapping;
    scene.background = texture;
  }, [texture, scene]);

  return null;
}
```

---

## 4. 공통 패턴과 베스트 프랙티스

### 4.1 코드 분할과 모듈화

**나쁜 예 - 모든 코드를 한 파일에:**
```jsx
// index.jsx (3000줄)
function App() {
  // 지도 관련 코드
  // 사이드바 관련 코드
  // Inspector 관련 코드
  // 유틸리티 함수
  // ...
}
```

**좋은 예 - 기능별로 분리:**
```
src/pizzaz/
├── index.jsx           # 메인 로직만
├── Sidebar.jsx         # 사이드바 컴포넌트
├── Inspector.jsx       # Inspector 컴포넌트
├── utils.js            # 유틸리티 함수
└── types.ts            # 타입 정의
```

### 4.2 Props Drilling 해결

**문제: Props를 여러 단계로 전달:**
```jsx
function App() {
  const [user, setUser] = useState(null);
  return <Parent user={user} setUser={setUser} />;
}

function Parent({ user, setUser }) {
  return <Child user={user} setUser={setUser} />;
}

function Child({ user, setUser }) {
  return <GrandChild user={user} setUser={setUser} />;
}

function GrandChild({ user, setUser }) {
  return <div>{user.name}</div>;  // 여기서 사용
}
```

**해결 1: Context API:**
```jsx
const UserContext = React.createContext();

function App() {
  const [user, setUser] = useState(null);
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <Parent />
    </UserContext.Provider>
  );
}

function GrandChild() {
  const { user } = useContext(UserContext);
  return <div>{user.name}</div>;
}
```

**해결 2: 커스텀 훅 (이 프로젝트 방식):**
```jsx
// use-user.ts
export function useUser() {
  return useOpenAiGlobal("user");
}

// 어디서든 사용
function GrandChild() {
  const user = useUser();
  return <div>{user.name}</div>;
}
```

### 4.3 에러 처리

```jsx
function SafeComponent() {
  const [error, setError] = useState(null);

  useEffect(() => {
    async function loadData() {
      try {
        const data = await fetchData();
        setData(data);
      } catch (err) {
        console.error("Failed to load data:", err);
        setError(err.message);
      }
    }
    loadData();
  }, []);

  if (error) {
    return (
      <div className="error">
        오류가 발생했습니다: {error}
      </div>
    );
  }

  return <div>...</div>;
}
```

### 4.4 성능 최적화

**1. useMemo - 비싼 계산 캐싱:**
```jsx
function ExpensiveList({ items }) {
  // ❌ 매 렌더링마다 계산
  const sortedItems = items.sort((a, b) => b.date - a.date);

  // ✅ items가 변경될 때만 계산
  const sortedItems = useMemo(() => {
    return items.sort((a, b) => b.date - a.date);
  }, [items]);

  return <div>...</div>;
}
```

**2. useCallback - 함수 메모이제이션:**
```jsx
function Parent() {
  const [count, setCount] = useState(0);

  // ❌ 매 렌더링마다 새 함수 생성
  const handleClick = () => {
    setCount(c => c + 1);
  };

  // ✅ 한 번만 생성
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  return <Child onClick={handleClick} />;
}
```

**3. React.memo - 컴포넌트 메모이제이션:**
```jsx
// ❌ 부모가 리렌더링되면 항상 리렌더링
function PlaceCard({ place }) {
  return <div>{place.name}</div>;
}

// ✅ place가 변경될 때만 리렌더링
const PlaceCard = React.memo(function PlaceCard({ place }) {
  return <div>{place.name}</div>;
});
```

### 4.5 접근성 (Accessibility)

**키보드 네비게이션:**
```jsx
<div
  role="button"
  tabIndex={0}
  onClick={handleClick}
  onKeyDown={(e) => {
    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      handleClick();
    }
  }}
>
  클릭 가능한 요소
</div>
```

**스크린 리더 지원:**
```jsx
<button
  aria-label="장소 삭제"
  aria-describedby="delete-help"
>
  <Trash2 aria-hidden="true" />
</button>
<span id="delete-help" className="sr-only">
  이 장소를 목록에서 삭제합니다
</span>
```

---

## 5. 애니메이션과 인터랙션

### 5.1 Framer Motion 핵심 패턴

**1. 기본 애니메이션:**
```jsx
<motion.div
  initial={{ opacity: 0, y: 20 }}
  animate={{ opacity: 1, y: 0 }}
  exit={{ opacity: 0, y: -20 }}
  transition={{ duration: 0.3 }}
>
  내용
</motion.div>
```

**2. 호버 애니메이션:**
```jsx
<motion.button
  whileHover={{ scale: 1.05 }}
  whileTap={{ scale: 0.95 }}
>
  버튼
</motion.button>
```

**3. 레이아웃 애니메이션:**
```jsx
<motion.div layout>
  {items.map(item => (
    <motion.div key={item.id} layout>
      {item.text}
    </motion.div>
  ))}
</motion.div>
```

**4. AnimatePresence - 컴포넌트 제거 애니메이션:**
```jsx
<AnimatePresence>
  {isVisible && (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}  // 제거될 때 애니메이션
    >
      내용
    </motion.div>
  )}
</AnimatePresence>
```

### 5.2 스프링 애니메이션

```jsx
<motion.div
  animate={{ x: 100 }}
  transition={{
    type: "spring",
    stiffness: 100,  // 강성 (높을수록 빠름)
    damping: 10,     // 감쇠 (높을수록 빨리 멈춤)
    mass: 1          // 질량
  }}
/>
```

**스프링 파라미터 효과:**
```
stiffness: 300, damping: 10  → 빠르고 튀는 애니메이션
stiffness: 100, damping: 20  → 부드러운 애니메이션
stiffness: 50, damping: 30   → 느리고 안정적인 애니메이션
```

### 5.3 제스처 (Gestures)

```jsx
<motion.div
  drag                      // 드래그 가능
  dragConstraints={{        // 드래그 범위 제한
    left: -100,
    right: 100,
    top: -100,
    bottom: 100
  }}
  dragElastic={0.2}         // 경계 탄성
  onDragEnd={(e, info) => {
    console.log("드래그 종료:", info.offset);
  }}
/>
```

---

## 💡 핵심 요약

### Pizzaz 지도 위젯
- **Mapbox GL JS**: 인터랙티브 지도
- **React Router**: URL 기반 상태 관리
- **Embla Carousel**: 모바일 캐러셀
- **Framer Motion**: 부드러운 애니메이션

### Todo 리스트 위젯
- **불변성 패턴**: 새 객체 생성으로 상태 업데이트
- **Reorder**: 드래그 앤 드롭 재정렬
- **React DatePicker**: 날짜 선택
- **Zoom Animation**: 리스트 ↔ 상세 전환

### Solar System 3D 위젯
- **React Three Fiber**: Three.js를 React로
- **useFrame**: 60fps 애니메이션 루프
- **OrbitControls**: 카메라 조작
- **Post-Processing**: Bloom, Depth of Field
- **Lerp**: 부드러운 카메라 이동

### 공통 패턴
- **모듈화**: 기능별 파일 분리
- **커스텀 훅**: 재사용 가능한 로직
- **성능 최적화**: useMemo, useCallback, React.memo
- **접근성**: ARIA 속성, 키보드 네비게이션

---

**4부 완료!** 다음은 5부 "MCP 서버 아키텍처 및 통신 메커니즘"입니다. 준비되면 요청해주세요! 🚀
