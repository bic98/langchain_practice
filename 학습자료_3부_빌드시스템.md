# OpenAI Apps SDK 완벽 학습 가이드 - 3부: 빌드 시스템

## 📚 목차
1. [Vite 빌드 시스템 이해하기](#1-vite-빌드-시스템-이해하기)
2. [개발 서버 구조 (vite.config.mts)](#2-개발-서버-구조-viteconfigmts)
3. [프로덕션 빌드 (build-all.mts)](#3-프로덕션-빌드-build-allmts)
4. [CSS 처리 전략](#4-css-처리-전략)
5. [해싱과 캐싱 전략](#5-해싱과-캐싱-전략)

---

## 1. Vite 빌드 시스템 이해하기

### 1.1 Vite란?

**Vite**(비트)는 차세대 프론트엔드 빌드 도구입니다.

**기존 도구 (Webpack) 문제점:**
```
┌──────────────────────────────────────┐
│  개발 서버 시작 시                    │
│  모든 파일을 번들링                   │
│  ⏱️ 30초~1분 소요                    │
└──────────────────────────────────────┘
```

**Vite의 해결책:**
```
┌──────────────────────────────────────┐
│  개발 서버 즉시 시작                  │
│  필요한 파일만 변환                   │
│  ⏱️ 1초 이내                         │
└──────────────────────────────────────┘
```

**핵심 특징:**

1. **빠른 개발 서버**
   - ES 모듈을 네이티브로 사용
   - 변경된 파일만 다시 로드 (HMR)

2. **최적화된 프로덕션 빌드**
   - Rollup 기반 번들링
   - 코드 분할, Tree-shaking

3. **플러그인 생태계**
   - React, Vue, Svelte 등 지원
   - TypeScript 기본 지원

### 1.2 개발 모드 vs 프로덕션 모드

```javascript
// 개발 모드
pnpm dev
// → 변환 없이 ES 모듈 그대로 제공
// → 빠른 시작, 빠른 HMR

// 프로덕션 모드
pnpm build
// → 모든 파일을 번들링
// → 최소화, 압축, 최적화
```

**차이점:**

| | 개발 모드 | 프로덕션 모드 |
|---|-----------|---------------|
| **목적** | 빠른 개발 | 최적화된 배포 |
| **속도** | 즉시 시작 | 느림 (번들링) |
| **파일 크기** | 큼 | 작음 (압축) |
| **소스맵** | 상세 | 간단 또는 없음 |
| **에러 메시지** | 상세 | 최소화 |

---

## 2. 개발 서버 구조 (vite.config.mts)

### 2.1 설정 파일 전체 구조

```typescript
// vite.config.mts
import { defineConfig, type Plugin } from "vite";
import react from "@vitejs/plugin-react";
import fg from "fast-glob";
import tailwindcss from "@tailwindcss/vite";

export default defineConfig({
  plugins: [
    tailwindcss(),
    react(),
    multiEntryDevEndpoints({ entries: inputs })
  ],
  server: { /* ... */ },
  build: { /* ... */ }
});
```

### 2.2 입력 파일 자동 발견

```typescript
function buildInputs() {
  // src/**/index.{tsx,jsx} 파일들 찾기
  const files = fg.sync("src/**/index.{tsx,jsx}", { dot: false });

  // 파일 경로 → 위젯 이름 매핑
  return Object.fromEntries(
    files.map((f) => [
      path.basename(path.dirname(f)),  // 디렉토리 이름
      path.resolve(f)                  // 절대 경로
    ])
  );
}

// 결과:
// {
//   "pizzaz": "/home/user/project/src/pizzaz/index.jsx",
//   "todo": "/home/user/project/src/todo/index.jsx",
//   "solar-system": "/home/user/project/src/solar-system/index.jsx"
// }
```

**왜 자동으로 찾나요?**
- 새 위젯을 추가할 때 설정 파일 수정 불필요
- `src/` 아래에 `index.jsx` 만들면 자동 인식!

### 2.3 플러그인 시스템

#### 2.3.1 Tailwind CSS 플러그인

```typescript
plugins: [
  tailwindcss(),  // Tailwind CSS 처리
  // ...
]
```

**동작:**
1. `.jsx` 파일에서 `className` 스캔
2. 사용된 클래스만 CSS로 변환
3. 최종 CSS 파일 생성

**예제:**
```jsx
// 소스 코드
<div className="flex items-center gap-3 p-4">

// 생성되는 CSS
.flex { display: flex; }
.items-center { align-items: center; }
.gap-3 { gap: 0.75rem; }
.p-4 { padding: 1rem; }
```

#### 2.3.2 React 플러그인

```typescript
plugins: [
  react(),  // React JSX 변환
  // ...
]
```

**동작:**
1. JSX → JavaScript 변환
2. React Fast Refresh (HMR) 설정
3. Development 모드 최적화

**변환 예제:**
```jsx
// 소스 코드
function App() {
  return <div>Hello</div>;
}

// 변환 후
import { jsx as _jsx } from "react/jsx-runtime";
function App() {
  return _jsx("div", { children: "Hello" });
}
```

#### 2.3.3 Multi-Entry 플러그인 (커스텀)

이 프로젝트의 핵심 플러그인입니다!

```typescript
function multiEntryDevEndpoints(options: {
  entries: Record<string, string>;
  globalCss?: string[];
  perEntryCssGlob?: string;
}): Plugin
```

**목적:** 여러 위젯을 동시에 개발할 수 있게 함

**주요 기능:**

1. **가상 엔드포인트 생성**
```
http://localhost:4444/pizzaz.html
http://localhost:4444/todo.html
http://localhost:4444/solar-system.html
```

2. **HTML 자동 생성**
```typescript
const renderDevHtml = (name: string): string => `<!doctype html>
<html>
<head>
  <script type="module" src="/${name}.js"></script>
  <link rel="stylesheet" href="/${name}.css">
</head>
<body>
  <div id="${name}-root"></div>
</body>
</html>`;
```

3. **CSS 자동 수집**
```typescript
// 글로벌 CSS
const globalCss = ["src/index.css"];

// 위젯별 CSS
const perEntryCss = fg.sync("**/*.{css,pcss}", {
  cwd: entryDir,
  ignore: ["**/*.module.*"]
});

// 합치기
const allCss = [...globalCss, ...perEntryCss];
```

### 2.4 가상 모듈 시스템

**가상 모듈이란?**
- 실제 파일이 아니라 **메모리에만 존재**하는 모듈
- 빌드 도구가 동적으로 생성

**이 프로젝트의 가상 모듈:**

```typescript
// 요청: /pizzaz.js
// → 가상 모듈 ID: "\0multi-entry:entry:pizzaz"

// resolveId 훅
resolveId(id: string) {
  if (id.endsWith(".js")) {
    const name = id.slice(0, -3);
    if (entries[name]) {
      return `${V_PREFIX}entry:${name}`;  // 가상 ID 반환
    }
  }
}

// load 훅
load(id: string) {
  if (id === "\0multi-entry:entry:pizzaz") {
    // 가상 모듈 내용 생성
    return `
      import "/@vite/client";              // HMR 클라이언트
      import "/pizzaz.css";                // CSS
      await import("/src/pizzaz/index.jsx");  // 실제 코드
    `;
  }
}
```

**실행 흐름:**
```
브라우저: GET /pizzaz.js
    ↓
Vite: resolveId("/pizzaz.js")
    ↓
Vite: id = "\0multi-entry:entry:pizzaz"
    ↓
Vite: load("\0multi-entry:entry:pizzaz")
    ↓
Vite: 가상 모듈 내용 생성
    ↓
브라우저: JavaScript 코드 수신
```

### 2.5 개발 서버 설정

```typescript
server: {
  port: 4444,           // 포트 번호
  strictPort: true,     // 포트 충돌 시 에러 (다른 포트로 안 바꿈)
  cors: true            // CORS 허용
}
```

**CORS가 왜 필요한가?**
```
┌─────────────────────────┐
│  ChatGPT (다른 도메인)   │
│  chat.openai.com        │
└─────────────────────────┘
         ↓ 위젯 로드 요청
┌─────────────────────────┐
│  개발 서버               │
│  localhost:4444         │
│  CORS 허용 ✅            │
└─────────────────────────┘
```

CORS가 없으면:
```
❌ Access to fetch at 'http://localhost:4444/pizzaz.html'
   from origin 'https://chat.openai.com' has been blocked by CORS policy
```

### 2.6 미들웨어 시스템

**미들웨어란?**
- HTTP 요청을 가로채서 처리하는 함수

```typescript
configureServer(server) {
  server.middlewares.use((req, res, next) => {
    const url = req.url.split("?")[0];

    // 1. 루트 요청 처리
    if (url === "/" || url === "/index.html") {
      const html = renderIndexHtml(names);
      res.setHeader("Content-Type", "text/html");
      res.end(html);
      return;
    }

    // 2. 위젯 HTML 요청 처리
    if (url.match(/^\/?([\w-]+)\.html$/)) {
      const name = url.match(/^\/?([\w-]+)\.html$/)[1];
      if (entries[name]) {
        const html = renderDevHtml(name);
        res.end(html);
        return;
      }
    }

    // 3. 다른 미들웨어로 넘김
    next();
  });
}
```

**요청 처리 순서:**
```
1. GET /
   → renderIndexHtml() → 위젯 목록 페이지

2. GET /pizzaz.html
   → renderDevHtml("pizzaz") → 위젯 HTML

3. GET /pizzaz.js
   → resolveId → load → 가상 모듈

4. GET /src/pizzaz/index.jsx
   → Vite의 기본 처리 (React 변환)
```

---

## 3. 프로덕션 빌드 (build-all.mts)

### 3.1 빌드 스크립트 전체 흐름

```typescript
// build-all.mts
const entries = fg.sync("src/**/index.{tsx,jsx}");
const outDir = "assets";

// 1. assets 폴더 삭제
fs.rmSync(outDir, { recursive: true, force: true });

// 2. 각 위젯 빌드
for (const file of entries) {
  const name = path.basename(path.dirname(file));

  // CSS 수집
  const cssToInclude = collectCss(file);

  // Vite 빌드
  await build(createConfig(name, file, cssToInclude));
}

// 3. 파일 해싱
hashOutputFiles();

// 4. HTML 생성
generateHtmlFiles();
```

### 3.2 CSS 수집 전략

**왜 CSS를 수집하나?**
- 각 위젯이 **독립적인 번들**이어야 함
- 위젯 A가 위젯 B의 CSS에 의존하면 안 됨

**수집 로직:**
```typescript
const entryAbs = path.resolve(file);  // /project/src/pizzaz/index.jsx
const entryDir = path.dirname(entryAbs);  // /project/src/pizzaz

// 1. 글로벌 CSS
const globalCss = ["src/index.css"].filter(p => fs.existsSync(p));

// 2. 위젯별 CSS
const perEntryCss = fg.sync("**/*.{css,pcss,scss,sass}", {
  cwd: entryDir,           // src/pizzaz 폴더만 검색
  absolute: true,
  ignore: ["**/*.module.*"]  // CSS 모듈 제외
});

// 3. 합치기 (순서 중요!)
const cssToInclude = [...globalCss, ...perEntryCss];
```

**예제:**
```
src/
├── index.css                  # 모든 위젯에 포함
├── pizzaz/
│   ├── index.jsx
│   ├── map.css               # pizzaz만 포함
│   └── sidebar.css           # pizzaz만 포함
└── todo/
    ├── index.jsx
    └── todo.css              # todo만 포함
```

**Pizzaz 빌드:**
```typescript
cssToInclude = [
  "/project/src/index.css",      // 글로벌
  "/project/src/pizzaz/map.css",
  "/project/src/pizzaz/sidebar.css"
]
```

### 3.3 가상 래퍼 플러그인

**문제:** Vite에 CSS 파일 목록을 어떻게 전달할까?

**해결:** 가상 래퍼 모듈 생성!

```typescript
function wrapEntryPlugin(
  virtualId: string,      // "\0virtual-entry:/project/src/pizzaz/index.jsx"
  entryFile: string,      // "/project/src/pizzaz/index.jsx"
  cssPaths: string[]      // CSS 파일 목록
): Plugin {
  return {
    name: `virtual-entry-wrapper:${entryFile}`,

    resolveId(id) {
      if (id === virtualId) return id;
    },

    load(id) {
      if (id !== virtualId) return null;

      // CSS import 문 생성
      const cssImports = cssPaths
        .map(css => `import ${JSON.stringify(css)};`)
        .join("\n");

      // 가상 모듈 내용
      return `
        ${cssImports}
        export * from ${JSON.stringify(entryFile)};
        import * as __entry from ${JSON.stringify(entryFile)};
        export default (__entry.default ?? __entry.App);
        import ${JSON.stringify(entryFile)};
      `;
    }
  };
}
```

**생성되는 가상 모듈:**
```javascript
import "/project/src/index.css";
import "/project/src/pizzaz/map.css";
import "/project/src/pizzaz/sidebar.css";

export * from "/project/src/pizzaz/index.jsx";

import * as __entry from "/project/src/pizzaz/index.jsx";
export default (__entry.default ?? __entry.App);

import "/project/src/pizzaz/index.jsx";
```

### 3.4 빌드 설정

```typescript
const createConfig = (): InlineConfig => ({
  plugins: [
    wrapEntryPlugin(virtualId, entryAbs, cssToInclude),
    tailwindcss(),
    react(),
    {
      name: "remove-manual-chunks",
      outputOptions(options) {
        // manualChunks 제거 → 단일 파일로 번들링
        delete (options as any).manualChunks;
      }
    }
  ],

  build: {
    target: "es2022",
    outDir: "assets",
    emptyOutDir: false,      // 다른 위젯 파일 삭제 안 함
    minify: "esbuild",       // 코드 최소화
    cssCodeSplit: false,     // CSS를 하나의 파일로

    rollupOptions: {
      input: virtualId,      // 가상 엔트리포인트
      output: {
        format: "es",
        entryFileNames: `${name}.js`,
        inlineDynamicImports: true,  // 동적 import도 하나의 파일로
        assetFileNames: (info) =>
          (info.name || "").endsWith(".css")
            ? `${name}.css`
            : `[name]-[hash][extname]`
      }
    }
  }
});
```

**주요 옵션 설명:**

**1. `cssCodeSplit: false`**
```
✅ 단일 CSS 파일:
assets/pizzaz.css  (모든 CSS 포함)

❌ 분할된 CSS 파일:
assets/pizzaz-chunk1.css
assets/pizzaz-chunk2.css
```

**2. `inlineDynamicImports: true`**
```javascript
// 소스 코드
const Component = await import('./Heavy.jsx');

// ❌ 분할됨
pizzaz.js
Heavy.js

// ✅ 합쳐짐
pizzaz.js (모든 코드 포함)
```

**3. `entryFileNames: ${name}.js`**
```
출력 파일명을 위젯 이름으로 지정
pizzaz.js (X pizzaz-a1b2c3d4.js)
```

### 3.5 빌드 실행

```typescript
for (const file of entries) {
  const name = path.basename(path.dirname(file));

  console.group(`Building ${name} (react)`);
  await build(createConfig());
  console.groupEnd();
}
```

**빌드 결과:**
```
assets/
├── pizzaz.js
├── pizzaz.css
├── todo.js
├── todo.css
├── solar-system.js
└── solar-system.css
```

---

## 4. CSS 처리 전략

### 4.1 Tailwind CSS 작동 방식

**1. 소스 코드 스캔**
```typescript
// tailwind.config.ts
content: [
  "./src/**/*.{html,js,ts,jsx,tsx}",
]
```

Tailwind가 이 파일들을 스캔해서 사용된 클래스를 찾습니다.

**2. 클래스 추출**
```jsx
// src/pizzaz/index.jsx
<div className="flex items-center gap-3 p-4 rounded-lg bg-white">
  <span className="text-xl font-bold">Hello</span>
</div>
```

추출된 클래스:
- `flex`
- `items-center`
- `gap-3`
- `p-4`
- `rounded-lg`
- `bg-white`
- `text-xl`
- `font-bold`

**3. CSS 생성**
```css
.flex { display: flex; }
.items-center { align-items: center; }
.gap-3 { gap: 0.75rem; }
.p-4 { padding: 1rem; }
.rounded-lg { border-radius: 0.5rem; }
.bg-white { background-color: #fff; }
.text-xl { font-size: 1.25rem; line-height: 1.75rem; }
.font-bold { font-weight: 700; }
```

**4. 최적화**
- 사용하지 않는 클래스는 제외
- 프로덕션: 최소화 (공백 제거, 압축)

### 4.2 CSS 임포트 순서

**왜 순서가 중요한가?**
- CSS는 **나중에 선언된 규칙이 우선**
- 잘못된 순서 → 스타일 깨짐

**올바른 순서:**
```typescript
const cssToInclude = [
  ...globalCss,    // 1. 글로벌 (Tailwind 기본값)
  ...perEntryCss   // 2. 위젯별 (커스텀 스타일)
];
```

**예제:**
```css
/* 1. src/index.css (글로벌) */
.button {
  padding: 0.5rem 1rem;
  border-radius: 0.25rem;
}

/* 2. src/pizzaz/map.css (위젯별) */
.button {
  background-color: #F46C21;  /* 오버라이드 */
}
```

최종 결과: 버튼이 주황색 배경

### 4.3 CSS 모듈 제외

```typescript
ignore: ["**/*.module.*"]
```

**CSS 모듈이란?**
- 클래스 이름을 자동으로 고유하게 만듦
- 이 프로젝트에서는 사용하지 않음

```css
/* styles.module.css */
.button { color: red; }

/* 빌드 후 */
.button_abc123 { color: red; }
```

---

## 5. 해싱과 캐싱 전략

### 5.1 파일 해싱

**해싱이란?**
- 파일 내용을 기반으로 짧은 문자열 생성
- 내용이 바뀌면 해시도 바뀜

**이 프로젝트의 해싱 방식:**
```typescript
// package.json 버전 기반 해싱
const h = crypto
  .createHash("sha256")
  .update(pkg.version, "utf8")  // "5.0.16"
  .digest("hex")
  .slice(0, 4);  // 앞 4글자만

console.log(h);  // 예: "a1b2"
```

**파일 이름 변경:**
```typescript
for (const out of outputs) {
  const dir = path.dirname(out);
  const ext = path.extname(out);
  const base = path.basename(out, ext);

  const newName = path.join(dir, `${base}-${h}${ext}`);
  fs.renameSync(out, newName);
}
```

**결과:**
```
assets/
├── pizzaz-a1b2.js
├── pizzaz-a1b2.css
├── todo-a1b2.js
└── todo-a1b2.css
```

### 5.2 왜 버전 기반 해싱인가?

**일반적인 해싱 방식:**
```typescript
// 파일 내용 기반 해싱
const hash = crypto.createHash("md5")
  .update(fileContent)
  .digest("hex")
  .slice(0, 8);

// pizzaz-3f8a91c2.js
```

**장점:** 파일이 변경되지 않으면 해시도 같음 → 캐싱 효율적

**이 프로젝트의 방식:**
```typescript
// 버전 기반 해싱
const hash = crypto.createHash("sha256")
  .update("5.0.16")
  .digest("hex")
  .slice(0, 4);

// pizzaz-a1b2.js
```

**장점:**
- 모든 위젯의 해시가 같음 → 관리 쉬움
- 버전 업데이트 시 모든 파일 갱신

**버전 업데이트 시나리오:**
```
버전 5.0.16 → 5.0.17

Before:
assets/
├── pizzaz-a1b2.js
├── todo-a1b2.js

After:
assets/
├── pizzaz-c3d4.js    # 새 해시
├── todo-c3d4.js      # 새 해시
```

### 5.3 HTML 생성

```typescript
const baseUrlRaw = process.env.BASE_URL || "http://localhost:4444";
const normalizedBaseUrl = baseUrlRaw.replace(/\/+$/, "");

for (const name of builtNames) {
  const html = `<!doctype html>
<html>
<head>
  <script type="module" src="${normalizedBaseUrl}/${name}.js"></script>
  <link rel="stylesheet" href="${normalizedBaseUrl}/${name}.css">
</head>
<body>
  <div id="${name}-root"></div>
</body>
</html>
`;

  // 두 버전 생성
  fs.writeFileSync(`assets/${name}-${h}.html`, html);  // 해시 버전
  fs.writeFileSync(`assets/${name}.html`, html);       // 일반 버전
}
```

**왜 두 버전?**

1. **해시 버전** (`pizzaz-a1b2.html`)
   - 버전 관리용
   - 구버전과 신버전 공존 가능

2. **일반 버전** (`pizzaz.html`)
   - 간편한 접근
   - MCP 서버에서 사용

### 5.4 BASE_URL 환경 변수

```bash
# 로컬 개발
BASE_URL=http://localhost:4444 pnpm build

# 프로덕션 배포
BASE_URL=https://my-server.com pnpm build
```

**생성되는 HTML:**
```html
<!-- 로컬 -->
<script type="module" src="http://localhost:4444/pizzaz.js"></script>

<!-- 프로덕션 -->
<script type="module" src="https://my-server.com/pizzaz.js"></script>
```

**왜 필요한가?**
```
┌─────────────────────────────┐
│       ChatGPT               │
└─────────────────────────────┘
        ↓ HTML 로드
┌─────────────────────────────┐
│    MCP 서버                  │
│    pizzaz.html 제공          │
└─────────────────────────────┘
        ↓ JS/CSS 로드
┌─────────────────────────────┐
│    정적 파일 서버            │
│    (BASE_URL)               │
│    pizzaz.js 제공           │
└─────────────────────────────┘
```

MCP 서버와 정적 파일 서버가 다를 수 있음!

---

## 6. 빌드 최적화 기법

### 6.1 Tree Shaking

**Tree Shaking이란?**
- 사용하지 않는 코드 제거
- 번들 크기 줄이기

```javascript
// math.js
export function add(a, b) { return a + b; }
export function multiply(a, b) { return a * b; }
export function divide(a, b) { return a / b; }

// app.js
import { add } from './math.js';
console.log(add(1, 2));

// 번들 결과 (multiply와 divide 제거됨)
function add(a, b) { return a + b; }
console.log(add(1, 2));
```

**이 프로젝트의 설정:**
```typescript
rollupOptions: {
  treeshake: true  // Tree shaking 활성화
}
```

### 6.2 코드 최소화 (Minification)

```typescript
build: {
  minify: "esbuild"
}
```

**변환 예제:**
```javascript
// 원본
function calculateTotal(items) {
  let total = 0;
  for (const item of items) {
    total += item.price;
  }
  return total;
}

// 최소화 후
function calculateTotal(e){let t=0;for(const r of e)t+=r.price;return t}
```

**최적화 기법:**
- 공백 제거
- 변수명 짧게
- 주석 제거
- 불필요한 세미콜론 제거

### 6.3 소스맵

```typescript
build: {
  sourcemap: true
}
```

**소스맵이란?**
- 최소화된 코드 ↔ 원본 코드 매핑 정보
- 디버깅에 필수!

**파일 생성:**
```
assets/
├── pizzaz-a1b2.js
└── pizzaz-a1b2.js.map  # 소스맵
```

**브라우저 개발자 도구:**
```
❌ 소스맵 없음:
   calculateTotal(e){let t=0;...}
   ↑ 이 코드 어디서 왔는지 모름

✅ 소스맵 있음:
   src/pizzaz/utils.js:15
   function calculateTotal(items) {
   ↑ 원본 코드 위치 표시
```

### 6.4 청크 전략

```typescript
rollupOptions: {
  output: {
    inlineDynamicImports: true
  }
}
```

**일반적인 청크 전략:**
```
main.js        (앱 코드)
vendor.js      (React 등 라이브러리)
chunk-abc.js   (동적 import)
```

**이 프로젝트의 전략:**
```
pizzaz.js      (모든 코드를 하나의 파일로)
```

**왜 하나로 합치나?**
- 위젯이 **독립적**이어야 함
- 여러 파일 → 로딩 복잡
- 단일 파일 → 간단한 배포

---

## 7. 개발 워크플로우

### 7.1 일반적인 개발 흐름

```bash
# 1. 프로젝트 클론 및 설치
git clone <repo>
pnpm install

# 2. 개발 서버 시작
pnpm dev
# → http://localhost:4444 접속

# 3. 코드 수정
# → HMR로 자동 리로드

# 4. 빌드
pnpm build
# → assets/ 폴더에 파일 생성

# 5. 빌드 결과 확인
pnpm serve
# → http://localhost:4444 접속
```

### 7.2 새 위젯 추가하기

```bash
# 1. 디렉토리 생성
mkdir src/my-widget

# 2. index.jsx 생성
cat > src/my-widget/index.jsx << 'EOF'
import { createRoot } from 'react-dom/client';

function MyWidget() {
  return <div>Hello, Widget!</div>;
}

createRoot(document.getElementById('my-widget-root')).render(<MyWidget />);
EOF

# 3. 개발 서버 재시작
# (자동으로 인식됨)

# 4. 접속
# http://localhost:4444/my-widget.html
```

**설정 파일 수정 불필요!** 자동으로 인식됩니다.

### 7.3 디버깅 팁

**1. 개발 서버 로그 확인**
```bash
pnpm dev

# 출력:
# Dev endpoints:
#   /pizzaz.html, /pizzaz.js, /pizzaz.css
#   /todo.html, /todo.js, /todo.css
```

**2. 브라우저 개발자 도구**
```
F12 → Sources 탭
└─ src/
   └─ pizzaz/
      └─ index.jsx  (원본 코드 보임)
```

**3. 빌드 오류 확인**
```bash
pnpm build

# 오류 예시:
# [vite]: Rollup failed to resolve import "non-existent"
# src/pizzaz/index.jsx (3:0)
```

**4. CSS 디버깅**
```jsx
// 임시로 인라인 스타일 사용
<div style={{ border: "1px solid red" }}>
  디버깅 중
</div>
```

---

## 💡 핵심 요약

### Vite 빌드 시스템
- **개발 모드**: 빠른 시작, HMR
- **프로덕션 모드**: 최적화된 번들
- **ES 모듈**: 네이티브 지원

### 개발 서버 (vite.config.mts)
- **자동 발견**: `src/**/index.{tsx,jsx}` 스캔
- **가상 모듈**: 동적으로 엔트리포인트 생성
- **CSS 수집**: 글로벌 + 위젯별 자동 수집
- **미들웨어**: 커스텀 HTML 제공

### 프로덕션 빌드 (build-all.mts)
- **독립 번들**: 각 위젯이 완전히 분리
- **CSS 인라인**: 하나의 CSS 파일로 통합
- **해싱**: package.json 버전 기반
- **HTML 생성**: BASE_URL 반영

### 최적화
- **Tree Shaking**: 미사용 코드 제거
- **Minification**: 코드 압축
- **Single Bundle**: 모든 코드를 하나의 파일로
- **Sourcemap**: 디버깅 지원

### 개발 워크플로우
1. `pnpm dev` - 개발 서버 시작
2. 코드 수정 - HMR 자동 적용
3. `pnpm build` - 프로덕션 빌드
4. `pnpm serve` - 빌드 결과 확인

---

**3부 완료!** 다음은 4부 "위젯 구현 상세 분석"입니다. 준비되면 요청해주세요! 🚀
